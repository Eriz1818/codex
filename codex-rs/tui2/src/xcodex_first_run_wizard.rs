use crate::key_hint;
use crate::render::Insets;
use crate::render::renderable::ColumnRenderable;
use crate::render::renderable::Renderable;
use crate::render::renderable::RenderableExt as _;
use crate::selection_list::selection_option_row;
use crate::tui::FrameRequester;
use crate::tui::Tui;
use crate::tui::TuiEvent;
use codex_core::config::Config;
use codex_core::config::should_run_xcodex_first_run_wizard;
use codex_core::config::xcodex_first_run_wizard_marker_path;
use color_eyre::Result;
use crossterm::event::KeyCode;
use crossterm::event::KeyEvent;
use crossterm::event::KeyEventKind;
use crossterm::event::KeyModifiers;
use ratatui::buffer::Buffer;
use ratatui::layout::Rect;
use ratatui::prelude::Widget;
use ratatui::style::Stylize as _;
use ratatui::text::Line;
use ratatui::widgets::Clear;
use ratatui::widgets::WidgetRef;
use std::path::Path;
use std::path::PathBuf;
use tokio_stream::StreamExt as _;

use crate::Cli;

pub(crate) enum WizardOutcome {
    Continue,
    ReloadConfig,
}

pub(crate) async fn run_xcodex_first_run_wizard_if_needed(
    tui: &mut Tui,
    cli: &Cli,
    config: &Config,
) -> Result<WizardOutcome> {
    let should_show =
        cli.force_setup_wizard || should_run_xcodex_first_run_wizard(&config.codex_home)?;
    if !should_show {
        return Ok(WizardOutcome::Continue);
    }

    let plan = StartFreshPlan::new(&config.codex_home);
    let mut screen =
        XcodexFirstRunWizardScreen::new(tui.frame_requester(), plan, cli.setup_dry_run);

    tui.draw(u16::MAX, |frame| {
        frame.render_widget_ref(&screen, frame.area());
    })?;

    let events = tui.event_stream();
    tokio::pin!(events);
    while !screen.is_done() {
        if let Some(event) = events.next().await {
            match event {
                TuiEvent::Key(key_event) => screen.handle_key(key_event),
                TuiEvent::Paste(_) => {}
                TuiEvent::Mouse(_) => {}
                TuiEvent::Draw => {
                    tui.draw(u16::MAX, |frame| {
                        frame.render_widget_ref(&screen, frame.area());
                    })?;
                }
            }
        } else {
            break;
        }
    }

    let mut reload_config = false;
    match screen.selection() {
        Some(SetupSelection::StartFreshApply) => {
            if !screen.dry_run() {
                screen.plan().apply()?;
                reload_config = true;
            }
        }
        Some(SetupSelection::DontShowAgain) => {
            if !screen.dry_run() {
                screen.plan().write_marker_only()?;
            }
        }
        Some(SetupSelection::Cancel) | None => {}
    }

    tui.terminal.clear()?;
    if reload_config {
        Ok(WizardOutcome::ReloadConfig)
    } else {
        Ok(WizardOutcome::Continue)
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
enum Step {
    Choose,
    Review,
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
enum ChooseSelection {
    StartFresh,
    Cancel,
    DontShowAgain,
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
enum ReviewSelection {
    Apply,
    Back,
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
enum SetupSelection {
    StartFreshApply,
    DontShowAgain,
    Cancel,
}

struct StartFreshPlan {
    codex_home: PathBuf,
}

impl StartFreshPlan {
    fn new(codex_home: &Path) -> Self {
        Self {
            codex_home: codex_home.to_path_buf(),
        }
    }

    fn config_path(&self) -> PathBuf {
        self.codex_home.join(codex_core::config::CONFIG_TOML_FILE)
    }

    fn marker_path(&self) -> PathBuf {
        xcodex_first_run_wizard_marker_path(&self.codex_home)
    }

    fn planned_lines(&self) -> Vec<Line<'static>> {
        vec![
            Line::from(vec![
                "Home: ".dim(),
                self.codex_home.display().to_string().into(),
            ]),
            Line::from(vec![
                "Write: ".dim(),
                self.config_path().display().to_string().dim(),
            ]),
            Line::from(vec![
                "Write: ".dim(),
                self.marker_path().display().to_string().dim(),
            ]),
        ]
    }

    fn apply(&self) -> std::io::Result<()> {
        std::fs::create_dir_all(&self.codex_home)?;

        let config_path = self.config_path();
        if !config_path.exists() {
            std::fs::write(
                &config_path,
                "# Generated by xcodex first-run setup wizard.\n# Set CODEX_HOME to explicitly choose a shared home.\n",
            )?;
        }

        self.write_marker_only()?;
        Ok(())
    }

    fn write_marker_only(&self) -> std::io::Result<()> {
        std::fs::create_dir_all(&self.codex_home)?;
        let marker = self.marker_path();
        if !marker.exists() {
            std::fs::write(marker, "")?;
        }
        Ok(())
    }
}

struct XcodexFirstRunWizardScreen {
    request_frame: FrameRequester,
    plan: StartFreshPlan,
    dry_run: bool,
    step: Step,
    choose_highlight: ChooseSelection,
    review_highlight: ReviewSelection,
    selection: Option<SetupSelection>,
}

impl XcodexFirstRunWizardScreen {
    fn new(request_frame: FrameRequester, plan: StartFreshPlan, dry_run: bool) -> Self {
        Self {
            request_frame,
            plan,
            dry_run,
            step: Step::Choose,
            choose_highlight: ChooseSelection::StartFresh,
            review_highlight: ReviewSelection::Apply,
            selection: None,
        }
    }

    fn is_done(&self) -> bool {
        self.selection.is_some()
    }

    fn selection(&self) -> Option<SetupSelection> {
        self.selection
    }

    fn plan(&self) -> &StartFreshPlan {
        &self.plan
    }

    fn dry_run(&self) -> bool {
        self.dry_run
    }

    fn handle_key(&mut self, key_event: KeyEvent) {
        if key_event.kind == KeyEventKind::Release {
            return;
        }

        if key_event.modifiers.contains(KeyModifiers::CONTROL)
            && matches!(key_event.code, KeyCode::Char('c') | KeyCode::Char('d'))
        {
            self.selection = Some(SetupSelection::Cancel);
            self.request_frame.schedule_frame();
            return;
        }

        match self.step {
            Step::Choose => self.handle_choose_key(key_event.code),
            Step::Review => self.handle_review_key(key_event.code),
        }
    }

    fn handle_choose_key(&mut self, code: KeyCode) {
        match code {
            KeyCode::Up | KeyCode::Char('k') => self.set_choose_highlight(self.choose_prev()),
            KeyCode::Down | KeyCode::Char('j') => self.set_choose_highlight(self.choose_next()),
            KeyCode::Char('1') => self.step = Step::Review,
            KeyCode::Char('2') => self.finish(SetupSelection::Cancel),
            KeyCode::Char('3') => self.finish(SetupSelection::DontShowAgain),
            KeyCode::Enter => match self.choose_highlight {
                ChooseSelection::StartFresh => self.step = Step::Review,
                ChooseSelection::Cancel => self.finish(SetupSelection::Cancel),
                ChooseSelection::DontShowAgain => self.finish(SetupSelection::DontShowAgain),
            },
            KeyCode::Esc => self.finish(SetupSelection::Cancel),
            _ => {}
        }
        self.request_frame.schedule_frame();
    }

    fn handle_review_key(&mut self, code: KeyCode) {
        match code {
            KeyCode::Up | KeyCode::Char('k') => self.set_review_highlight(self.review_prev()),
            KeyCode::Down | KeyCode::Char('j') => self.set_review_highlight(self.review_next()),
            KeyCode::Char('1') => self.finish(SetupSelection::StartFreshApply),
            KeyCode::Char('2') => self.step = Step::Choose,
            KeyCode::Enter => match self.review_highlight {
                ReviewSelection::Apply => self.finish(SetupSelection::StartFreshApply),
                ReviewSelection::Back => self.step = Step::Choose,
            },
            KeyCode::Esc => self.step = Step::Choose,
            _ => {}
        }
        self.request_frame.schedule_frame();
    }

    fn finish(&mut self, selection: SetupSelection) {
        self.selection = Some(selection);
    }

    fn set_choose_highlight(&mut self, highlight: ChooseSelection) {
        self.choose_highlight = highlight;
    }

    fn choose_next(&self) -> ChooseSelection {
        match self.choose_highlight {
            ChooseSelection::StartFresh => ChooseSelection::Cancel,
            ChooseSelection::Cancel => ChooseSelection::DontShowAgain,
            ChooseSelection::DontShowAgain => ChooseSelection::StartFresh,
        }
    }

    fn choose_prev(&self) -> ChooseSelection {
        match self.choose_highlight {
            ChooseSelection::StartFresh => ChooseSelection::DontShowAgain,
            ChooseSelection::Cancel => ChooseSelection::StartFresh,
            ChooseSelection::DontShowAgain => ChooseSelection::Cancel,
        }
    }

    fn set_review_highlight(&mut self, highlight: ReviewSelection) {
        self.review_highlight = highlight;
    }

    fn review_next(&self) -> ReviewSelection {
        match self.review_highlight {
            ReviewSelection::Apply => ReviewSelection::Back,
            ReviewSelection::Back => ReviewSelection::Apply,
        }
    }

    fn review_prev(&self) -> ReviewSelection {
        match self.review_highlight {
            ReviewSelection::Apply => ReviewSelection::Back,
            ReviewSelection::Back => ReviewSelection::Apply,
        }
    }
}

impl WidgetRef for &XcodexFirstRunWizardScreen {
    fn render_ref(&self, area: Rect, buf: &mut Buffer) {
        Clear.render(area, buf);
        let mut column = ColumnRenderable::new();

        column.push("");
        column.push(Line::from(vec![
            "  xcodex setup".bold(),
            " ".into(),
            "(first run)".dim(),
        ]));
        column.push("");

        match self.step {
            Step::Choose => {
                column.push(
                    Line::from(
                        "xcodex keeps its config/state separate by default so it can coexist with upstream codex."
                            .to_string(),
                    )
                    .inset(Insets::tlbr(0, 2, 0, 0)),
                );
                column.push("");
                column.push(
                    Line::from(vec![
                        "Home: ".dim(),
                        self.plan.codex_home.display().to_string().into(),
                    ])
                    .inset(Insets::tlbr(0, 2, 0, 0)),
                );
                column.push("");

                column.push(selection_option_row(
                    0,
                    "Start fresh (review changes)".to_string(),
                    self.choose_highlight == ChooseSelection::StartFresh,
                ));
                column.push(selection_option_row(
                    1,
                    "Skip for now".to_string(),
                    self.choose_highlight == ChooseSelection::Cancel,
                ));
                column.push(selection_option_row(
                    2,
                    "Donâ€™t show again".to_string(),
                    self.choose_highlight == ChooseSelection::DontShowAgain,
                ));
                column.push("");
                column.push(
                    Line::from(vec![
                        "Press ".dim(),
                        key_hint::plain(KeyCode::Enter).into(),
                        " to continue".dim(),
                    ])
                    .inset(Insets::tlbr(0, 2, 0, 0)),
                );
                if self.dry_run {
                    column.push(
                        Line::from(vec!["Dry-run: ".dim(), "no files will be written".yellow()])
                            .inset(Insets::tlbr(0, 2, 0, 0)),
                    );
                }
            }
            Step::Review => {
                column.push(
                    Line::from("Review planned changes:".to_string())
                        .inset(Insets::tlbr(0, 2, 0, 0)),
                );
                column.push("");

                for line in self.plan.planned_lines() {
                    column.push(line.inset(Insets::tlbr(0, 4, 0, 0)));
                }
                column.push("");

                let apply_label = if self.dry_run {
                    "Exit (dry-run)".to_string()
                } else {
                    "Apply".to_string()
                };
                column.push(selection_option_row(
                    0,
                    apply_label,
                    self.review_highlight == ReviewSelection::Apply,
                ));
                column.push(selection_option_row(
                    1,
                    "Back".to_string(),
                    self.review_highlight == ReviewSelection::Back,
                ));
                column.push("");
                column.push(
                    Line::from(vec![
                        "Press ".dim(),
                        key_hint::plain(KeyCode::Enter).into(),
                        " to select".dim(),
                    ])
                    .inset(Insets::tlbr(0, 2, 0, 0)),
                );
            }
        }

        column.render(area, buf);
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::custom_terminal::Terminal;
    use crate::test_backend::VT100Backend;
    use insta::assert_snapshot;
    use ratatui::layout::Rect;

    fn render_snapshot(screen: &XcodexFirstRunWizardScreen) -> String {
        let width: u16 = 80;
        let height: u16 = 16;
        let backend = VT100Backend::new(width, height);
        let mut terminal = Terminal::with_options(backend).expect("terminal");
        terminal.set_viewport_area(Rect::new(0, 0, width, height));

        {
            let mut frame = terminal.get_frame();
            frame.render_widget_ref(screen, frame.area());
        }
        terminal.flush().expect("flush");
        terminal.backend().to_string()
    }

    #[test]
    fn first_run_wizard_choose_snapshot() {
        let plan = StartFreshPlan::new(Path::new("XC_HOME_DOES_NOT_EXIST"));
        let screen = XcodexFirstRunWizardScreen::new(FrameRequester::test_dummy(), plan, false);
        assert_snapshot!("xcodex_first_run_wizard_choose", render_snapshot(&screen));
    }

    #[test]
    fn first_run_wizard_review_snapshot() {
        let plan = StartFreshPlan::new(Path::new("XC_HOME_DOES_NOT_EXIST"));
        let mut screen = XcodexFirstRunWizardScreen::new(FrameRequester::test_dummy(), plan, true);
        screen.step = Step::Review;
        assert_snapshot!("xcodex_first_run_wizard_review", render_snapshot(&screen));
    }
}
