//! Generate Rust types for the in-repo `codex-hooks-sdk` crate.
//!
//! Usage:
//!   cd codex-rs
//!   cargo run -p codex-core --bin hooks_rust_sdk --features hooks-schema --quiet \
//!     > hooks-sdk/src/generated.rs

#[cfg(feature = "hooks-schema")]
use std::collections::BTreeMap;
#[cfg(feature = "hooks-schema")]
use std::collections::BTreeSet;
#[cfg(feature = "hooks-schema")]
use std::fmt::Write;

#[cfg(feature = "hooks-schema")]
use codex_core::hooks::HookPayload;
#[cfg(feature = "hooks-schema")]
use schemars::schema_for;
#[cfg(feature = "hooks-schema")]
use serde_json::Value;

#[cfg(not(feature = "hooks-schema"))]
fn main() {
    eprintln!("error: build with `--features hooks-schema` to enable schema/type generation");
    std::process::exit(2);
}

#[cfg(feature = "hooks-schema")]
fn main() {
    let schema = schema_for!(HookPayload);
    let schema_json = match serde_json::to_value(&schema) {
        Ok(value) => value,
        Err(err) => {
            eprintln!("error: failed to serialize schema: {err}");
            std::process::exit(1);
        }
    };

    match generate_rust_sdk(&schema_json) {
        Ok(out) => print!("{out}"),
        Err(err) => {
            eprintln!("error: failed to generate Rust SDK types: {err}");
            std::process::exit(1);
        }
    }
}

#[cfg(feature = "hooks-schema")]
fn generate_rust_sdk(schema: &Value) -> Result<String, String> {
    let definitions = schema
        .get("definitions")
        .and_then(Value::as_object)
        .ok_or("expected definitions object")?;

    let one_of = schema
        .get("oneOf")
        .and_then(Value::as_array)
        .ok_or("expected top-level oneOf array")?;

    let root_required: BTreeSet<String> = schema
        .get("required")
        .and_then(Value::as_array)
        .map(|arr| {
            arr.iter()
                .filter_map(Value::as_str)
                .map(str::to_string)
                .collect()
        })
        .unwrap_or_default();

    let root_properties = schema
        .get("properties")
        .and_then(Value::as_object)
        .ok_or("expected root properties object")?;

    let mut variants: BTreeMap<String, Value> = BTreeMap::new();
    for variant in one_of {
        let properties = variant
            .get("properties")
            .and_then(Value::as_object)
            .ok_or("variant missing properties object")?;
        let ty = properties
            .get("type")
            .and_then(|v| v.get("enum"))
            .and_then(Value::as_array)
            .and_then(|arr| arr.first())
            .and_then(Value::as_str)
            .ok_or("variant type property missing enum string")?;
        variants.insert(ty.to_string(), variant.clone());
    }

    let mut out = String::new();
    out.push_str(
        r#"// Code generated by `codex-core/src/bin/hooks_rust_sdk.rs`. DO NOT EDIT.
//
// This module is generated from the Rust hook payload schema (source-of-truth).
//
// Re-generate from the repo:
//   cd codex-rs
//   cargo run -p codex-core --bin hooks_rust_sdk --features hooks-schema --quiet \
//     > hooks-sdk/src/generated.rs

use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::collections::BTreeMap;

pub type ExtraFields = BTreeMap<String, Value>;

"#,
    );

    for (name, def) in definitions {
        if let Some(block) = rust_string_enum(def, name) {
            out.push_str(&block);
            out.push('\n');
            continue;
        }
        if let Some(block) = rust_object_struct(def, name, definitions) {
            out.push_str(&block);
            out.push('\n');
        }
    }

    let mut event_types: Vec<&String> = variants.keys().collect();
    event_types.sort();

    for event_type in event_types {
        let variant = variants.get(event_type).ok_or("variant disappeared")?;
        let name = format!("{}Payload", pascal_case(event_type));
        let properties = variant
            .get("properties")
            .and_then(Value::as_object)
            .ok_or("variant missing properties object")?;

        let mut required: BTreeSet<String> = root_required.clone();
        if let Some(arr) = variant.get("required").and_then(Value::as_array) {
            for key in arr.iter().filter_map(Value::as_str) {
                required.insert(key.to_string());
            }
        }

        writeln!(
            &mut out,
            "#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]"
        )
        .map_err(|_| "formatting failed".to_string())?;
        writeln!(&mut out, "pub struct {name} {{").map_err(|_| "formatting failed".to_string())?;

        let mut merged: BTreeMap<String, Value> = BTreeMap::new();
        for (key, schema) in root_properties {
            merged.insert(key.clone(), schema.clone());
        }
        for (key, schema) in properties {
            merged.insert(key.clone(), schema.clone());
        }

        let mut keys: Vec<(&String, &Value)> = merged.iter().collect();
        keys.sort_by(|(a, _), (b, _)| a.as_str().cmp(b.as_str()));
        for (key, prop_schema) in keys {
            let field_name = snake_case(key);
            let mut rust_ty = rust_type_for_schema(prop_schema, definitions);

            let is_required = required.contains(key.as_str());
            let is_nullable = schema_allows_null(prop_schema);
            if (!is_required || is_nullable) && !rust_ty.starts_with("Option<") {
                rust_ty = format!("Option<{rust_ty}>");
            }

            writeln!(&mut out, "    #[serde(rename = \"{key}\")]")
                .map_err(|_| "formatting failed".to_string())?;
            writeln!(&mut out, "    pub {field_name}: {rust_ty},")
                .map_err(|_| "formatting failed".to_string())?;
        }

        out.push_str("    #[serde(flatten)]\n");
        out.push_str("    pub extra: ExtraFields,\n");
        out.push_str("}\n\n");
    }

    Ok(out)
}

#[cfg(feature = "hooks-schema")]
fn rust_string_enum(schema: &Value, name: &str) -> Option<String> {
    let literals = schema_string_literals(schema)?;
    let mut variants: Vec<(String, String)> = literals
        .into_iter()
        .map(|lit| {
            let variant = pascal_case(&lit);
            (lit, variant)
        })
        .collect();
    variants.sort();

    let mut out = String::new();
    out.push_str("#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\n");
    out.push_str(&format!("pub enum {name} {{\n"));
    for (lit, variant) in variants {
        out.push_str(&format!("    #[serde(rename = \"{lit}\")]\n"));
        out.push_str(&format!("    {variant},\n"));
    }
    out.push_str("    #[serde(other)]\n");
    out.push_str("    Unknown,\n");
    out.push_str("}\n");
    Some(out)
}

#[cfg(feature = "hooks-schema")]
fn rust_object_struct(
    schema: &Value,
    name: &str,
    definitions: &serde_json::Map<String, Value>,
) -> Option<String> {
    if !schema_is_object_struct(schema) {
        return None;
    }

    let properties = schema.get("properties")?.as_object()?;
    let required: BTreeSet<String> = schema
        .get("required")
        .and_then(Value::as_array)
        .map(|arr| {
            arr.iter()
                .filter_map(Value::as_str)
                .map(str::to_string)
                .collect()
        })
        .unwrap_or_default();

    let mut out = String::new();
    writeln!(
        &mut out,
        "#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]"
    )
    .ok()?;
    writeln!(&mut out, "pub struct {name} {{").ok()?;

    let mut keys: Vec<(&String, &Value)> = properties.iter().collect();
    keys.sort_by(|(a, _), (b, _)| a.as_str().cmp(b.as_str()));

    for (key, prop_schema) in keys {
        let field_name = snake_case(key);
        let mut rust_ty = rust_type_for_schema(prop_schema, definitions);

        let is_required = required.contains(key.as_str());
        let is_nullable = schema_allows_null(prop_schema);
        if (!is_required || is_nullable) && !rust_ty.starts_with("Option<") {
            rust_ty = format!("Option<{rust_ty}>");
        }

        writeln!(&mut out, "    #[serde(rename = \"{key}\")]").ok()?;
        writeln!(&mut out, "    pub {field_name}: {rust_ty},").ok()?;
    }

    writeln!(&mut out, "    #[serde(flatten)]").ok()?;
    writeln!(&mut out, "    pub extra: ExtraFields,").ok()?;
    writeln!(&mut out, "}}").ok()?;

    Some(out)
}

#[cfg(feature = "hooks-schema")]
fn schema_string_literals(schema: &Value) -> Option<Vec<String>> {
    if let Some(arr) = schema.get("enum").and_then(Value::as_array) {
        let mut out = Vec::new();
        for v in arr {
            out.push(v.as_str()?.to_string());
        }
        return Some(out);
    }

    let one_of = schema.get("oneOf")?.as_array()?;
    let mut out = Vec::new();
    for v in one_of {
        out.extend(schema_string_literals(v)?);
    }
    Some(out)
}

#[cfg(feature = "hooks-schema")]
fn rust_type_for_schema(schema: &Value, definitions: &serde_json::Map<String, Value>) -> String {
    let schema = strip_null(schema);

    if let Some(reference) = schema.get("$ref").and_then(Value::as_str)
        && let Some((_, name)) = reference.rsplit_once('/')
        && let Some(def) = definitions.get(name)
    {
        if schema_string_literals(def).is_some() || schema_is_object_struct(def) {
            return name.to_string();
        }
        return rust_type_for_schema(def, definitions);
    }

    if let Some(ty) = schema_type(schema) {
        match ty {
            "string" => return "String".to_string(),
            "boolean" => return "bool".to_string(),
            "integer" => {
                if let Some(format) = schema.get("format").and_then(Value::as_str) {
                    match format {
                        "uint32" => return "u32".to_string(),
                        "uint64" => return "u64".to_string(),
                        "uint" => return "u64".to_string(),
                        _ => {}
                    }
                }

                if schema_minimum_non_negative(schema) {
                    return "u64".to_string();
                }
                return "i64".to_string();
            }
            "array" => {
                let items = schema
                    .get("items")
                    .map(|s| rust_type_for_schema(s, definitions))
                    .unwrap_or_else(|| "Value".to_string());
                return format!("Vec<{items}>");
            }
            "object" => return "Value".to_string(),
            _ => {}
        }
    }

    "Value".to_string()
}

#[cfg(feature = "hooks-schema")]
fn schema_is_object_struct(schema: &Value) -> bool {
    schema.get("oneOf").is_none() && schema.get("type").and_then(Value::as_str) == Some("object")
}

#[cfg(feature = "hooks-schema")]
fn schema_type(schema: &Value) -> Option<&str> {
    if let Some(ty) = schema.get("type").and_then(Value::as_str) {
        return Some(ty);
    }
    let arr = schema.get("type").and_then(Value::as_array)?;
    arr.iter()
        .filter_map(Value::as_str)
        .find(|ty| *ty != "null")
}

#[cfg(feature = "hooks-schema")]
fn schema_allows_null(schema: &Value) -> bool {
    if let Some(arr) = schema.get("type").and_then(Value::as_array) {
        return arr.iter().any(|v| v.as_str() == Some("null"));
    }
    if let Some(any_of) = schema.get("anyOf").and_then(Value::as_array) {
        return any_of
            .iter()
            .any(|v| v.get("type").and_then(Value::as_str) == Some("null"));
    }
    false
}

#[cfg(feature = "hooks-schema")]
fn strip_null(schema: &Value) -> &Value {
    if let Some(any_of) = schema.get("anyOf").and_then(Value::as_array) {
        for arm in any_of {
            if arm.get("type").and_then(Value::as_str) != Some("null") {
                return arm;
            }
        }
    }
    schema
}

#[cfg(feature = "hooks-schema")]
fn schema_minimum_non_negative(schema: &Value) -> bool {
    schema
        .get("minimum")
        .and_then(Value::as_f64)
        .map(|v| v >= 0.0)
        .unwrap_or(false)
}

#[cfg(feature = "hooks-schema")]
fn pascal_case(input: &str) -> String {
    let mut out = String::new();
    for part in input.split(['-', '_', ' ']) {
        if part.is_empty() {
            continue;
        }
        let mut chars = part.chars();
        if let Some(first) = chars.next() {
            out.extend(first.to_uppercase());
            out.push_str(chars.as_str());
        }
    }
    out
}

#[cfg(feature = "hooks-schema")]
fn snake_case(input: &str) -> String {
    let mut out = input.replace('-', "_");
    if out == "type" {
        out = "event_type".to_string();
    }
    out
}
