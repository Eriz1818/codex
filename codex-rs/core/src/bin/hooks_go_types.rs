//! Generate Go types for xcodex external hook payloads.
//!
//! Usage:
//!   cd codex-rs
//!   cargo run -p codex-core --bin hooks_go_types --features hooks-schema --quiet \
//!     > common/src/hooks_sdk_assets/go/hooksdk/types.go

#[cfg(feature = "hooks-schema")]
use std::collections::BTreeMap;
#[cfg(feature = "hooks-schema")]
use std::collections::BTreeSet;
#[cfg(feature = "hooks-schema")]
use std::fmt::Write;

#[cfg(feature = "hooks-schema")]
use codex_core::hooks::HookPayload;
#[cfg(feature = "hooks-schema")]
use schemars::schema_for;
#[cfg(feature = "hooks-schema")]
use serde_json::Value;

#[cfg(not(feature = "hooks-schema"))]
fn main() {
    eprintln!("error: build with `--features hooks-schema` to enable schema/type generation");
    std::process::exit(2);
}

#[cfg(feature = "hooks-schema")]
fn main() {
    let schema = schema_for!(HookPayload);
    let schema_json = match serde_json::to_value(&schema) {
        Ok(value) => value,
        Err(err) => {
            eprintln!("error: failed to serialize schema: {err}");
            std::process::exit(1);
        }
    };

    match generate_go_types(&schema_json) {
        Ok(out) => print!("{out}"),
        Err(err) => {
            eprintln!("error: failed to generate Go types: {err}");
            std::process::exit(1);
        }
    }
}

#[cfg(feature = "hooks-schema")]
fn generate_go_types(schema: &Value) -> Result<String, String> {
    let definitions = schema
        .get("definitions")
        .and_then(Value::as_object)
        .ok_or("expected definitions object")?;

    let one_of = schema
        .get("oneOf")
        .and_then(Value::as_array)
        .ok_or("expected top-level oneOf array")?;

    let root_required: BTreeSet<String> = schema
        .get("required")
        .and_then(Value::as_array)
        .map(|arr| {
            arr.iter()
                .filter_map(Value::as_str)
                .map(str::to_string)
                .collect()
        })
        .unwrap_or_default();

    let mut variants: BTreeMap<String, Value> = BTreeMap::new();
    for variant in one_of {
        let properties = variant
            .get("properties")
            .and_then(Value::as_object)
            .ok_or("variant missing properties object")?;
        let ty = properties
            .get("type")
            .and_then(|v| v.get("enum"))
            .and_then(Value::as_array)
            .and_then(|arr| arr.first())
            .and_then(Value::as_str)
            .ok_or("variant type property missing enum string")?;
        variants.insert(ty.to_string(), variant.clone());
    }

    let mut out = String::new();
    out.push_str(
        r#"// Code generated by `codex-core/src/bin/hooks_go_types.rs`. DO NOT EDIT.
//
// xCodex hooks kit: Go typed helpers for external hooks.
//
// This file is installed under `$CODEX_HOME/hooks/templates/go/` by:
//   xcodex hooks install go
//
// Re-generate from the repo:
//   cd codex-rs
//   cargo run -p codex-core --bin hooks_go_types --features hooks-schema --quiet \
//     > common/src/hooks_sdk_assets/go/hooksdk/types.go
package hooksdk

import (
	"encoding/json"
)

// HookPayload is implemented by all typed hook payload variants.
// It also preserves the raw JSON object for forward compatibility.
type HookPayload interface {
	EventType() string
	Raw() map[string]any
}

// HookPayloadBase are the common fields present in all hook payloads.
type HookPayloadBase struct {
	SchemaVersion uint32 `json:"schema-version"`
	EventID       string `json:"event-id"`
	Timestamp     string `json:"timestamp"`
	Type          string `json:"type"`
}

// ParseHookPayload parses a hook JSON payload into a typed struct based on its `type`.
// Unknown event types are returned as *UnknownPayload.
func ParseHookPayload(data []byte) (HookPayload, error) {
	var base HookPayloadBase
	if err := json.Unmarshal(data, &base); err != nil {
		return nil, err
	}

	switch base.Type {
"#,
    );

    for event_type in variants.keys() {
        let name = pascal_case(event_type) + "Payload";
        writeln!(
            &mut out,
            "\tcase {event_type:?}:\n\t\tvar p {name}\n\t\tif err := json.Unmarshal(data, &p); err != nil {{\n\t\t\treturn nil, err\n\t\t}}\n\t\treturn &p, nil"
        )
        .map_err(|_| "formatting failed".to_string())?;
    }

    out.push_str(
        r#"
	default:
		var raw map[string]any
		if err := json.Unmarshal(data, &raw); err != nil {
			return nil, err
		}
		return &UnknownPayload{Base: base, RawPayload: raw}, nil
	}
}

// UnknownPayload is returned when the payload type is not recognized by this SDK version.
type UnknownPayload struct {
	Base       HookPayloadBase
	RawPayload map[string]any
}

func (p *UnknownPayload) EventType() string { return p.Base.Type }
func (p *UnknownPayload) Raw() map[string]any { return p.RawPayload }

"#,
    );

    if let Some(block) = go_string_enum_type(definitions.get("ApprovalKind"), "ApprovalKind") {
        out.push_str(&block);
        out.push('\n');
    }
    if let Some(block) = go_string_enum_type(definitions.get("ToolCallStatus"), "ToolCallStatus") {
        out.push_str(&block);
        out.push('\n');
    }

    for (event_type, variant) in &variants {
        let name = pascal_case(event_type) + "Payload";
        let properties = variant
            .get("properties")
            .and_then(Value::as_object)
            .ok_or("variant missing properties object")?;

        let mut required: BTreeSet<String> = root_required.clone();
        if let Some(arr) = variant.get("required").and_then(Value::as_array) {
            for key in arr.iter().filter_map(Value::as_str) {
                required.insert(key.to_string());
            }
        }

        writeln!(&mut out, "type {name} struct {{").map_err(|_| "formatting failed".to_string())?;
        writeln!(&mut out, "\tBase HookPayloadBase")
            .map_err(|_| "formatting failed".to_string())?;
        writeln!(&mut out, "\tRawPayload map[string]any `json:\"-\"`")
            .map_err(|_| "formatting failed".to_string())?;

        let mut keys: Vec<(&String, &Value)> = properties.iter().collect();
        keys.sort_by(|(a, _), (b, _)| a.as_str().cmp(b.as_str()));

        for (key, prop_schema) in keys {
            if key == "type" || key == "schema-version" || key == "event-id" || key == "timestamp" {
                continue;
            }

            let field_name = go_field_name(key);
            let mut go_ty = go_type_for_schema(prop_schema);

            // Optional OR nullable => pointer (except slices/maps/interface)
            let is_required = required.contains(key.as_str());
            let is_nullable = schema_allows_null(prop_schema);
            if (!is_required || is_nullable)
                && !go_ty.starts_with("[]")
                && !go_ty.starts_with("map[")
                && go_ty != "any"
                && !go_ty.starts_with("*")
            {
                go_ty = format!("*{go_ty}");
            }

            writeln!(&mut out, "\t{field_name} {go_ty} `json:\"{key}\"`")
                .map_err(|_| "formatting failed".to_string())?;
        }

        out.push_str("}\n\n");
        writeln!(
            &mut out,
            "func (p *{name}) EventType() string {{ return p.Base.Type }}"
        )
        .map_err(|_| "formatting failed".to_string())?;
        writeln!(
            &mut out,
            "func (p *{name}) Raw() map[string]any {{ return p.RawPayload }}"
        )
        .map_err(|_| "formatting failed".to_string())?;

        out.push_str(
            r#"
func (p *"#,
        );
        out.push_str(&name);
        out.push_str(
            r#") UnmarshalJSON(data []byte) error {
	var raw map[string]any
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	type alias "#,
        );
        out.push_str(&name);
        out.push_str(
            r#"
	var a alias
	if err := json.Unmarshal(data, &a); err != nil {
		return err
	}
	*p = "#,
        );
        out.push_str(&name);
        out.push_str(
            r#"(a)
	p.RawPayload = raw
	return nil
}

"#,
        );
    }

    Ok(out)
}

#[cfg(feature = "hooks-schema")]
fn go_string_enum_type(schema: Option<&Value>, name: &str) -> Option<String> {
    let values = schema?.get("enum")?.as_array()?;
    let mut out = String::new();
    writeln!(&mut out, "type {name} string").ok()?;
    writeln!(&mut out).ok()?;
    writeln!(&mut out, "const (").ok()?;
    for v in values {
        let value = v.as_str()?;
        let const_name = format!("{name}{}", go_field_name(value));
        writeln!(&mut out, "\t{const_name} {name} = {value:?}").ok()?;
    }
    writeln!(&mut out, ")").ok()?;
    Some(out)
}

#[cfg(feature = "hooks-schema")]
fn schema_allows_null(schema: &Value) -> bool {
    match schema.get("type") {
        Some(Value::String(s)) => s == "null",
        Some(Value::Array(arr)) => arr.iter().any(|v| v.as_str() == Some("null")),
        _ => schema
            .get("anyOf")
            .and_then(Value::as_array)
            .is_some_and(|arr| {
                arr.iter()
                    .any(|v| v.get("type").and_then(Value::as_str) == Some("null"))
            }),
    }
}

#[cfg(feature = "hooks-schema")]
fn go_type_for_schema(schema: &Value) -> String {
    if let Some(reference) = schema.get("$ref").and_then(Value::as_str)
        && let Some((_, name)) = reference.rsplit_once('/')
    {
        return match name {
            "ApprovalKind" => "ApprovalKind".to_string(),
            "ToolCallStatus" => "ToolCallStatus".to_string(),
            _ => "any".to_string(),
        };
    }

    if let Some(ty) = schema.get("type") {
        match ty {
            Value::String(s) if s == "string" => return "string".to_string(),
            Value::String(s) if s == "integer" => return "int".to_string(),
            Value::String(s) if s == "number" => return "float64".to_string(),
            Value::String(s) if s == "boolean" => return "bool".to_string(),
            Value::String(s) if s == "object" => return "map[string]any".to_string(),
            Value::String(s) if s == "array" => {
                let items = schema.get("items").unwrap_or(&Value::Null);
                let item_ty = go_type_for_schema(items);
                return format!("[]{item_ty}");
            }
            Value::String(s) if s == "null" => return "any".to_string(),
            Value::Array(arr) => {
                // union. If it's array+null with items => slice; else fall back to any.
                let has_array = arr.iter().any(|v| v.as_str() == Some("array"));
                if has_array {
                    let items = schema.get("items").unwrap_or(&Value::Null);
                    let item_ty = go_type_for_schema(items);
                    return format!("[]{item_ty}");
                }
                if arr.iter().any(|v| v.as_str() == Some("string")) {
                    return "string".to_string();
                }
                return "any".to_string();
            }
            _ => {}
        }
    }

    if let Some(arr) = schema.get("anyOf").and_then(Value::as_array) {
        // Prefer non-null branch if possible.
        for v in arr {
            if v.get("type").and_then(Value::as_str) == Some("null") {
                continue;
            }
            return go_type_for_schema(v);
        }
        return "any".to_string();
    }

    // Enum of strings.
    if schema.get("enum").is_some() {
        return "string".to_string();
    }

    "any".to_string()
}

#[cfg(feature = "hooks-schema")]
fn go_field_name(input: &str) -> String {
    let mut out = String::new();
    let mut upper_next = true;
    for ch in input.chars() {
        if ch == '-' || ch == '_' || ch == ' ' {
            upper_next = true;
            continue;
        }
        if upper_next {
            for up in ch.to_uppercase() {
                out.push(up);
            }
            upper_next = false;
        } else {
            out.push(ch);
        }
    }
    if out.is_empty() { "X".to_string() } else { out }
}

#[cfg(feature = "hooks-schema")]
fn pascal_case(s: &str) -> String {
    go_field_name(s)
}
